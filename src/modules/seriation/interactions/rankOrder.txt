`

/**
 * Rank Order - Sort rows (supports manual and drag-and-drop) 
 *
 * interaction mechanics inspired from
 * @see https://h5p.org/content-types/sort-the-paragraphs
 * @see https://learningapps.org
 */

import { BaseInteraction } from "../../../core/BaseInteraction";
import { InteractionConfig } from "../../../shared";
import { SeriationData } from "../../../shared";
import { EduBlock } from "../../../ui";
import { shuffle } from "../../../shared";
import { seriationGrading } from "../implementation";

export class RankOrder extends BaseInteraction<SeriationData> {
	
	private parts: string[] = [];
	private blocks: EduBlock[] = [];

	private currentIndex = 0;

	constructor(data: SeriationData, config: InteractionConfig) {
		super(data, config);
		
		this.parts = shuffle(this.data.items);
		this.initializeProgress(this.parts.length);

		// this.boundPointerMove = this.handlePointerMove.bind(this);
		// this.boundPointerUp = this.handlePointerUp.bind(this);
	}

	protected initialize(): void {
		window.addEventListener("pointermove", this.boundPointerMove);
		window.addEventListener("pointerup", this.boundPointerUp);
	}

	protected cleanup(): void {
		window.removeEventListener("pointermove", this.boundPointerMove);
		window.removeEventListener("pointerup", this.boundPointerUp);
	}

	protected onVariantChange(newVariant: string): void {
		this.blocks.forEach(b => {
			b.variant = newVariant;
		});
	}

	// ==================== RENDERING ====================

	render(): void {
		
		// 1 - add entrance/exit animations for edu-chip 
		// 2 - container must be a grid, better responsiveness
		// 3 - 
		this.innerHtml = `
			
			<style>
				.container {}
				.label-zone {
					display: grid;
					grid-template-rows: 1fr;
					place-items: center;
				}
			</style>

			<div id="container" className="container"></div>
			<div id="label-container" className="label-zone"></div>
		`
	}

	createBlock(): void {
		this.parts.forEach(p => {
			const chip = document.createElement("edu-chip");
			chip.variant = this.config.variant;
			chip.className = "";	
			chip.addEventListener("pointerdown", (e) => handlePointerDown(e, chip)); 
		});	
	}

	updateLabel(): void {
		this.labelContainer.remove(this.currentLabel);
		this.labelContainer.appendChild(this.blocks[this.currentIndex]);
	}

	private handlePointerDown(e: PointerEvent, chip: EduChip): void {}

	private handlePointerMove(e: PointerEvent): void {}

	private handlePointerUp(e: PointerEvent): void {}

	private checkZoneOverlap(clientX: number, clientY: number): void {}

	// ==================== INTERACTION LOGIC ====================

	getCurrentState(): any {
	}

	isInteractionComplete(): boolean {
	}

	onHint(): void {
	}
	
	// manipulate the current label (shell/parent logic are the ones responsiable for handing the nav changes)
	// the interaction itself DOES NOT implement its own button for navigation 
	public setSteps(steps: number): void {
		this.currentIndex = steps;
		this.updateLabel();
	}

	public submit(): void {
	}

	// ==================== RESET ====================

	public reset(): void {
	}
}

if (!customElements.get('rank-order')) {
	customElements.define('rank-order', RankOrder);
}

`
